// ============================================
// LUMINA LIVE STUDIO - CODE GENERATOR
// Generates JSX code from current prop values
// ============================================

import { AnimationSchema, ControlValues, ControlConfig } from './types';

/**
 * Formats a value for JSX output based on its type
 */
function formatValueForJSX(value: unknown, config: ControlConfig): string {
    switch (config.type) {
        case 'text':
        case 'color':
            return `"${value}"`;
        case 'range':
            return `{${value}}`;
        case 'boolean':
            return value ? '{true}' : '{false}';
        case 'select':
            return `"${value}"`;
        default:
            return `{${JSON.stringify(value)}}`;
    }
}

/**
 * Checks if a value is different from the default
 */
function isDifferentFromDefault(value: unknown, config: ControlConfig): boolean {
    return value !== config.defaultValue;
}

/**
 * Generates JSX source code for a component with given props
 */
export function generateSourceCode(
    schema: AnimationSchema,
    currentValues: ControlValues,
    options: {
        includeDefaults?: boolean;
        indent?: number;
        wrapInContainer?: boolean;
    } = {}
): string {
    const { includeDefaults = false, indent = 2, wrapInContainer = false } = options;
    const spaces = ' '.repeat(indent);
    
    // Filter props to include
    const propsToInclude = Object.entries(schema.controls).filter(([key, config]) => {
        const value = currentValues[key];
        return includeDefaults || isDifferentFromDefault(value, config);
    });

    // Build props string
    let propsString = '';
    if (propsToInclude.length > 0) {
        const propLines = propsToInclude.map(([key, config]) => {
            const value = currentValues[key];
            const formattedValue = formatValueForJSX(value, config);
            return `${spaces}${key}=${formattedValue}`;
        });
        
        if (propLines.length <= 3) {
            // Inline format for few props
            propsString = ' ' + propsToInclude.map(([key, config]) => {
                const value = currentValues[key];
                const formattedValue = formatValueForJSX(value, config);
                return `${key}=${formattedValue}`;
            }).join(' ');
        } else {
            // Multi-line format for many props
            propsString = '\n' + propLines.join('\n') + '\n';
        }
    }

    // Generate component JSX
    const componentJSX = `<${schema.componentName}${propsString}${propsString.includes('\n') ? '' : ' '}/>`;

    if (wrapInContainer) {
        return `<div className="w-full h-full flex items-center justify-center">\n${spaces}${componentJSX}\n</div>`;
    }

    return componentJSX;
}

/**
 * Generates a complete React component file
 */
export function generateComponentFile(
    schema: AnimationSchema,
    currentValues: ControlValues
): string {
    const componentJSX = generateSourceCode(schema, currentValues, { 
        includeDefaults: false, 
        indent: 4 
    });

    return `// Generated by Lumina Live Studio
import { ${schema.componentName} } from '@/components/${schema.componentName}';

export function Custom${schema.componentName}() {
    return (
        ${componentJSX}
    );
}
`;
}

/**
 * Generates import statement for the component
 */
export function generateImportStatement(schema: AnimationSchema): string {
    return `import { ${schema.componentName} } from '@/components/${schema.componentName}';`;
}

/**
 * Formats code with syntax highlighting markers (for display)
 */
export function formatCodeForDisplay(code: string): { 
    raw: string; 
    highlighted: Array<{ text: string; type: 'tag' | 'prop' | 'value' | 'text' }> 
} {
    // Simple tokenizer for display
    const tokens: Array<{ text: string; type: 'tag' | 'prop' | 'value' | 'text' }> = [];
    
    // This is a simplified version - in production you'd use a proper parser
    const tagMatch = code.match(/<(\w+)/);
    if (tagMatch) {
        tokens.push({ text: '<', type: 'text' });
        tokens.push({ text: tagMatch[1], type: 'tag' });
    }
    
    // Extract props
    const propRegex = /(\w+)=(["'{])(.*?)\2/g;
    let match;
    while ((match = propRegex.exec(code)) !== null) {
        tokens.push({ text: match[1], type: 'prop' });
        tokens.push({ text: '=', type: 'text' });
        tokens.push({ text: match[0].slice(match[1].length + 1), type: 'value' });
    }

    return { raw: code, highlighted: tokens };
}
